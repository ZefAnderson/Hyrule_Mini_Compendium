"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EntryImage = exports.type_category = void 0;
const stream_1 = require("stream");
const fs = require("fs");
const https = require("https");
/**
 * Converts items of a category to their respective data types
 * @param category_data API response of category
 * @returns {AnyCategory}
 */
function type_category(category_data) {
    let res = [];
    if (Object.keys(category_data).length === 2) {
        res = category_data;
    }
    else {
        category_data = category_data;
        if (category_data[0].category === "equipment") {
            res = category_data;
        }
        else if (category_data[0].category === "materials") {
            res = category_data;
        }
        else if (category_data[0].category === "monsters") {
            res = category_data;
        }
        else if (category_data[0].category === "treasure") {
            res = category_data;
        }
    }
    return res;
}
exports.type_category = type_category;
/**
 * Represents the image of an entry.
 * @param {compendium} compendium_instance Instance of `compendium`
 * @param {EntryType} entry ID or name of entry
 */
class EntryImage {
    constructor(compendium_instance, entry) {
        this.compendium_instance = compendium_instance;
        this.entry = entry;
    }
    /**
     * Gets the `stream.Transform` object of image, useful for file uploads
     * @param {ImageGetStreamCallback} callback Function to be executed with image
     * @param {number} timeout Time to wait for response before executing @param error_callback
     * @param {Function} [error_callback=(err)=>{throw(err)] Function to be executed on error
     */
    get_stream(callback, timeout = this.compendium_instance.default_timeout, error_callback = (err) => { throw err; }) {
        this.compendium_instance.get_entry(this.entry, (data) => {
            let req = https.get(data["image"], (resp) => {
                let strm = new stream_1.Transform();
                resp.on("data", (chunk) => {
                    strm.push(chunk);
                });
                resp.on("end", () => {
                    callback(strm);
                });
            }).on("error", error_callback);
            req.on("timeout", req.destroy);
        }, timeout, error_callback);
    }
    /**
     * Downloads the image of an entry
     * @param {EntryType} entry ID or name of entry
     * @param {string} [output_file] File path of which image is to saved, default: "./[entry name].png"
     * @param {Function} [callback=(err)=>{throw err}] @param callback of https://nodejs.org/api/fs.html#fs_fs_writefile_file_data_options_callback
     * @param {number} timeout Time to wait for response before executing @param error_callback
     * @param {Function} [error_callback=(err)=>{throw(err)] Function to be executed on error
     */
    download(output_file, callback = () => { }, timeout = this.compendium_instance.default_timeout, error_callback = (err) => { throw err; }) {
        this.compendium_instance.get_entry(this.entry, (data) => {
            let req = https.get(data["image"], (resp) => {
                let strm = new stream_1.Transform();
                resp.on("data", (chunk) => {
                    strm.push(chunk);
                });
                resp.on("end", () => {
                    fs.writeFile(output_file !== null && output_file !== void 0 ? output_file : (data["name"] + ".png").replace(" ", "_"), strm.read(), callback);
                });
            }).on("error", error_callback);
            req.on("timeout", req.destroy);
        }, timeout, error_callback);
    }
}
exports.EntryImage = EntryImage;
